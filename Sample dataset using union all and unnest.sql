with t as
(
  select 1 as cust, 0 as val
  union all
  select 2 as cust, 19 as val
  union all
  select 3 as cust, 34 as val
  union all
  select 4 as cust, 81 as val
  union all
  select 5 as cust, 0 as val
  union all
  select 6 as cust, 65 as val
  union all
  select 7 as cust, 98 as val
  union all
  select 8 as cust, 23 as val
  union all
  select 9 as cust, 56 as val
)
select
  count(distinct if(val > 0, cust, 0)) as qty_0,
  count(distinct if(val > 0, cust, null)) as qty_null
from t;

with t as
(
  select 
    cust, 
    val
  from 
    unnest(array<struct<cust int64, val int64>>[
      (1, 40),
      (2, 22),
      (3, 0),
      (4, 98),
      (5, 9),
      (6, 65),
      (7, 0),
      (8, 43),
      (9, 61)
    ])
)
select
  count(distinct if(val > 0, cust, 0)) as qty_0,
  count(distinct if(val > 0, cust, null)) as qty_null
from t;

with t as -- Begin a Common Table Expression (CTE) named 't' to define a temporary result set that can be referenced within the query.
(
  select
    cust, -- Select the 'cust' identifier, representing unique customer IDs.
    if(mod(cust, (select cast(floor(rand() * 8) + 2 as int64) as rand_2_9)) = 0, 0, cast(rand() * 100 as int64)) as val
    -- For the column 'val':
    -- 1. Inside the 'mod', calculate (cust % X), where 'X' is a random integer from 2 to 9, generated by:
    --    a. Select a random float with 'rand()', scale it to [0, 8) by multiplying by 8, then use 'floor' to get [0, 7].
    --    b. Add 2 to shift the range to [2, 9), then 'cast' to an INT64 for use in modulus and comparisons.
    -- 2. Using 'if' statement, check:
    --    If the result of 'mod(cust, X)' is 0, set 'val' to 0 (meaning the customer ID is a multiple of the random number X).
    --    Otherwise, generate a random integer for 'val', using 'cast(rand() * 100 as int64)' to create a random number between 0 and 99.

  from unnest(generate_array(1, cast(floor(rand() * 991) + 10 as int64))) as cust
  -- Create a series of customer IDs:
  -- 1. 'generate_array(1, N)' generates sequential integers from 1 to N.
  -- 2. Compute N by generating a random float with 'rand()', scale to [0, 991) by multiplying by 991 (range up to 1000 - 10),
  --    then add 10, ensuring the final random count is between 10 and 1000.
  -- 3. 'cast' the result to INT64 for array construction.
  -- 4. 'unnest' takes this array and expands it into a table with a single column 'cust'.

)
select
  count(distinct if(val > 0, cust, 0)) as qty_0,
  -- Calculate the count of distinct 'cust' where 'val' is greater than 0,
  -- used to determine how many distinct non-zero 'cust' identifiers are there,
  -- with a logical distinction: returns 0 if 'val' is not greater than 0, included for aggregation purpose consistency.

  count(distinct if(val > 0, cust, null)) as qty_null
  -- Calculate the count of distinct 'cust' where 'val' is greater than 0,
  -- However, it counts only actual distinct 'cust' ignoring zero-equivalent,
  -- shows differences when considering null handling in aggregations. 
from t; -- The main query accesses the result set defined in the CTE 't'.

/* Random 6 digit for customer ID */
with t as
(
  select 
    cust,
    if(mod(cust, (select cast(floor(rand() * 8) + 2 as int64))) = 0, 0, cast(rand() * 100 as int64)) as val
  from unnest(
    array(
      select cast(floor(rand() * 900000) + 100000 as int64) as random_6_digit
      from unnest(generate_array(1, cast(floor(rand() * 991) + 10 as int64))) as iteration -- _ (underscore can used as a placeholder when the alias is not needed)
    )
  ) as cust
)
select
  count(distinct if(val > 0, cust, 0)) as qty_0,
  count(distinct if(val > 0, cust, null)) as qty_null
from t;
